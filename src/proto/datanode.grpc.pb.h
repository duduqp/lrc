// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: datanode.proto
#ifndef GRPC_datanode_2eproto__INCLUDED
#define GRPC_datanode_2eproto__INCLUDED

#include "datanode.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace datanode {

// 
class FromDataNode final {
 public:
  static constexpr char const* service_full_name() {
    return "datanode.FromDataNode";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
  };
  typedef Service AsyncService;
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef Service CallbackService;
  #endif

  typedef Service ExperimentalCallbackService;
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

// From Coodinator to DN
class FromCoodinator final {
 public:
  static constexpr char const* service_full_name() {
    return "datanode.FromCoodinator";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // deal with dir creating too
    virtual ::grpc::Status handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asynchandleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsynchandleuploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsynchandleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsynchandleuploadRaw(context, request, cq));
    }
    virtual ::grpc::Status handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asynchandledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsynchandledownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsynchandledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsynchandledownloadRaw(context, request, cq));
    }
    virtual ::grpc::Status clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncclearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsyncclearallstripeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncclearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncclearallstripeRaw(context, request, cq));
    }
    virtual ::grpc::Status dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncdolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsyncdolocallyrepairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncdolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncdolocallyrepairRaw(context, request, cq));
    }
    virtual ::grpc::Status docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncdocompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsyncdocompleterepairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncdocompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncdocompleterepairRaw(context, request, cq));
    }
    virtual ::grpc::Status clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncclearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsyncclearstripeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncclearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncclearstripeRaw(context, request, cq));
    }
    virtual ::grpc::Status checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asynccheckalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsynccheckaliveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsynccheckalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsynccheckaliveRaw(context, request, cq));
    }
    // with deletion , migration use only
    virtual ::grpc::Status handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asynchandlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsynchandlepullRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsynchandlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsynchandlepullRaw(context, request, cq));
    }
    virtual ::grpc::Status handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asynchandlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsynchandlepushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsynchandlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsynchandlepushRaw(context, request, cq));
    }
    // pull from handledownload nodes and perform some operations then push to some handleupload nodes
    // worker node use only
    virtual ::grpc::Status pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncpull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(Asyncpull_perform_pushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncpull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncpull_perform_pushRaw(context, request, cq));
    }
    virtual ::grpc::Status renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::datanode::RequestResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> Asyncrenameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(AsyncrenameblockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>> PrepareAsyncrenameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>>(PrepareAsyncrenameblockRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // deal with dir creating too
      virtual void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // with deletion , migration use only
      virtual void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // pull from handledownload nodes and perform some operations then push to some handleupload nodes
      // worker node use only
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsynchandleuploadRaw(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsynchandleuploadRaw(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsynchandledownloadRaw(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsynchandledownloadRaw(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsyncclearallstripeRaw(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncclearallstripeRaw(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsyncdolocallyrepairRaw(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncdolocallyrepairRaw(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsyncdocompleterepairRaw(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncdocompleterepairRaw(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsyncclearstripeRaw(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncclearstripeRaw(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsynccheckaliveRaw(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsynccheckaliveRaw(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsynchandlepullRaw(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsynchandlepullRaw(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsynchandlepushRaw(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsynchandlepushRaw(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* Asyncpull_perform_pushRaw(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncpull_perform_pushRaw(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* AsyncrenameblockRaw(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::datanode::RequestResult>* PrepareAsyncrenameblockRaw(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asynchandleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsynchandleuploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsynchandleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsynchandleuploadRaw(context, request, cq));
    }
    ::grpc::Status handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asynchandledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsynchandledownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsynchandledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsynchandledownloadRaw(context, request, cq));
    }
    ::grpc::Status clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncclearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsyncclearallstripeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncclearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncclearallstripeRaw(context, request, cq));
    }
    ::grpc::Status dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncdolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsyncdolocallyrepairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncdolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncdolocallyrepairRaw(context, request, cq));
    }
    ::grpc::Status docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncdocompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsyncdocompleterepairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncdocompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncdocompleterepairRaw(context, request, cq));
    }
    ::grpc::Status clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncclearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsyncclearstripeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncclearstripe(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncclearstripeRaw(context, request, cq));
    }
    ::grpc::Status checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asynccheckalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsynccheckaliveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsynccheckalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsynccheckaliveRaw(context, request, cq));
    }
    ::grpc::Status handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asynchandlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsynchandlepullRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsynchandlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsynchandlepullRaw(context, request, cq));
    }
    ::grpc::Status handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asynchandlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsynchandlepushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsynchandlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsynchandlepushRaw(context, request, cq));
    }
    ::grpc::Status pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncpull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(Asyncpull_perform_pushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncpull_perform_push(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncpull_perform_pushRaw(context, request, cq));
    }
    ::grpc::Status renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::datanode::RequestResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> Asyncrenameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(AsyncrenameblockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>> PrepareAsyncrenameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>>(PrepareAsyncrenameblockRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handleupload(::grpc::ClientContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handleupload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handledownload(::grpc::ClientContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handledownload(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void clearallstripe(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void clearallstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void dolocallyrepair(::grpc::ClientContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void dolocallyrepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void docompleterepair(::grpc::ClientContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void docompleterepair(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void clearstripe(::grpc::ClientContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void clearstripe(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void checkalive(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void checkalive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handlepull(::grpc::ClientContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handlepull(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handlepush(::grpc::ClientContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void handlepush(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void pull_perform_push(::grpc::ClientContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void pull_perform_push(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void renameblock(::grpc::ClientContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void renameblock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::datanode::RequestResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsynchandleuploadRaw(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsynchandleuploadRaw(::grpc::ClientContext* context, const ::datanode::UploadCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsynchandledownloadRaw(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsynchandledownloadRaw(::grpc::ClientContext* context, const ::datanode::DownloadCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsyncclearallstripeRaw(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncclearallstripeRaw(::grpc::ClientContext* context, const ::datanode::ClearallstripeCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsyncdolocallyrepairRaw(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncdolocallyrepairRaw(::grpc::ClientContext* context, const ::datanode::NodesLocation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsyncdocompleterepairRaw(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncdocompleterepairRaw(::grpc::ClientContext* context, const ::datanode::StripeLocation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsyncclearstripeRaw(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncclearstripeRaw(::grpc::ClientContext* context, const ::datanode::StripeId& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsynccheckaliveRaw(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsynccheckaliveRaw(::grpc::ClientContext* context, const ::datanode::CheckaliveCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsynchandlepullRaw(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsynchandlepullRaw(::grpc::ClientContext* context, const ::datanode::HandlePullCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsynchandlepushRaw(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsynchandlepushRaw(::grpc::ClientContext* context, const ::datanode::HandlePushCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* Asyncpull_perform_pushRaw(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncpull_perform_pushRaw(::grpc::ClientContext* context, const ::datanode::OP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* AsyncrenameblockRaw(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::datanode::RequestResult>* PrepareAsyncrenameblockRaw(::grpc::ClientContext* context, const ::datanode::RenameCMD& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_handleupload_;
    const ::grpc::internal::RpcMethod rpcmethod_handledownload_;
    const ::grpc::internal::RpcMethod rpcmethod_clearallstripe_;
    const ::grpc::internal::RpcMethod rpcmethod_dolocallyrepair_;
    const ::grpc::internal::RpcMethod rpcmethod_docompleterepair_;
    const ::grpc::internal::RpcMethod rpcmethod_clearstripe_;
    const ::grpc::internal::RpcMethod rpcmethod_checkalive_;
    const ::grpc::internal::RpcMethod rpcmethod_handlepull_;
    const ::grpc::internal::RpcMethod rpcmethod_handlepush_;
    const ::grpc::internal::RpcMethod rpcmethod_pull_perform_push_;
    const ::grpc::internal::RpcMethod rpcmethod_renameblock_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // deal with dir creating too
    virtual ::grpc::Status handleupload(::grpc::ServerContext* context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status handledownload(::grpc::ServerContext* context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status clearallstripe(::grpc::ServerContext* context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status dolocallyrepair(::grpc::ServerContext* context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status docompleterepair(::grpc::ServerContext* context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status clearstripe(::grpc::ServerContext* context, const ::datanode::StripeId* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status checkalive(::grpc::ServerContext* context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response);
    // with deletion , migration use only
    virtual ::grpc::Status handlepull(::grpc::ServerContext* context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status handlepush(::grpc::ServerContext* context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response);
    // pull from handledownload nodes and perform some operations then push to some handleupload nodes
    // worker node use only
    virtual ::grpc::Status pull_perform_push(::grpc::ServerContext* context, const ::datanode::OP* request, ::datanode::RequestResult* response);
    virtual ::grpc::Status renameblock(::grpc::ServerContext* context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_handleupload() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandleupload(::grpc::ServerContext* context, ::datanode::UploadCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_handledownload() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandledownload(::grpc::ServerContext* context, ::datanode::DownloadCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearallstripe() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclearallstripe(::grpc::ServerContext* context, ::datanode::ClearallstripeCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_dolocallyrepair() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdolocallyrepair(::grpc::ServerContext* context, ::datanode::NodesLocation* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_docompleterepair() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdocompleterepair(::grpc::ServerContext* context, ::datanode::StripeLocation* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearstripe() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclearstripe(::grpc::ServerContext* context, ::datanode::StripeId* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_checkalive() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcheckalive(::grpc::ServerContext* context, ::datanode::CheckaliveCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_handlepull() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandlepull(::grpc::ServerContext* context, ::datanode::HandlePullCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_handlepush() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandlepush(::grpc::ServerContext* context, ::datanode::HandlePushCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pull_perform_push() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpull_perform_push(::grpc::ServerContext* context, ::datanode::OP* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_renameblock() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrenameblock(::grpc::ServerContext* context, ::datanode::RenameCMD* request, ::grpc::ServerAsyncResponseWriter< ::datanode::RequestResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_handleupload<WithAsyncMethod_handledownload<WithAsyncMethod_clearallstripe<WithAsyncMethod_dolocallyrepair<WithAsyncMethod_docompleterepair<WithAsyncMethod_clearstripe<WithAsyncMethod_checkalive<WithAsyncMethod_handlepull<WithAsyncMethod_handlepush<WithAsyncMethod_pull_perform_push<WithAsyncMethod_renameblock<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_handleupload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::UploadCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::UploadCMD* request, ::datanode::RequestResult* response) { return this->handleupload(context, request, response); }));}
    void SetMessageAllocatorFor_handleupload(
        ::grpc::experimental::MessageAllocator< ::datanode::UploadCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::UploadCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handleupload(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handleupload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_handledownload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::DownloadCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::DownloadCMD* request, ::datanode::RequestResult* response) { return this->handledownload(context, request, response); }));}
    void SetMessageAllocatorFor_handledownload(
        ::grpc::experimental::MessageAllocator< ::datanode::DownloadCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::DownloadCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handledownload(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handledownload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_clearallstripe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::ClearallstripeCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::ClearallstripeCMD* request, ::datanode::RequestResult* response) { return this->clearallstripe(context, request, response); }));}
    void SetMessageAllocatorFor_clearallstripe(
        ::grpc::experimental::MessageAllocator< ::datanode::ClearallstripeCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::ClearallstripeCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* clearallstripe(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* clearallstripe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_dolocallyrepair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::NodesLocation, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::NodesLocation* request, ::datanode::RequestResult* response) { return this->dolocallyrepair(context, request, response); }));}
    void SetMessageAllocatorFor_dolocallyrepair(
        ::grpc::experimental::MessageAllocator< ::datanode::NodesLocation, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::NodesLocation, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* dolocallyrepair(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* dolocallyrepair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_docompleterepair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::StripeLocation, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::StripeLocation* request, ::datanode::RequestResult* response) { return this->docompleterepair(context, request, response); }));}
    void SetMessageAllocatorFor_docompleterepair(
        ::grpc::experimental::MessageAllocator< ::datanode::StripeLocation, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::StripeLocation, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* docompleterepair(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* docompleterepair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_clearstripe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::StripeId, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::StripeId* request, ::datanode::RequestResult* response) { return this->clearstripe(context, request, response); }));}
    void SetMessageAllocatorFor_clearstripe(
        ::grpc::experimental::MessageAllocator< ::datanode::StripeId, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::StripeId, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* clearstripe(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* clearstripe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_checkalive() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::CheckaliveCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::CheckaliveCMD* request, ::datanode::RequestResult* response) { return this->checkalive(context, request, response); }));}
    void SetMessageAllocatorFor_checkalive(
        ::grpc::experimental::MessageAllocator< ::datanode::CheckaliveCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::CheckaliveCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* checkalive(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* checkalive(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_handlepull() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::HandlePullCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::HandlePullCMD* request, ::datanode::RequestResult* response) { return this->handlepull(context, request, response); }));}
    void SetMessageAllocatorFor_handlepull(
        ::grpc::experimental::MessageAllocator< ::datanode::HandlePullCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::HandlePullCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handlepull(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handlepull(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_handlepush() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::HandlePushCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::HandlePushCMD* request, ::datanode::RequestResult* response) { return this->handlepush(context, request, response); }));}
    void SetMessageAllocatorFor_handlepush(
        ::grpc::experimental::MessageAllocator< ::datanode::HandlePushCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::HandlePushCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handlepush(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handlepush(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_pull_perform_push() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::OP, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::OP* request, ::datanode::RequestResult* response) { return this->pull_perform_push(context, request, response); }));}
    void SetMessageAllocatorFor_pull_perform_push(
        ::grpc::experimental::MessageAllocator< ::datanode::OP, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::OP, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* pull_perform_push(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* pull_perform_push(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_renameblock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::datanode::RenameCMD, ::datanode::RequestResult>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::datanode::RenameCMD* request, ::datanode::RequestResult* response) { return this->renameblock(context, request, response); }));}
    void SetMessageAllocatorFor_renameblock(
        ::grpc::experimental::MessageAllocator< ::datanode::RenameCMD, ::datanode::RequestResult>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::datanode::RenameCMD, ::datanode::RequestResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* renameblock(
      ::grpc::CallbackServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* renameblock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_handleupload<ExperimentalWithCallbackMethod_handledownload<ExperimentalWithCallbackMethod_clearallstripe<ExperimentalWithCallbackMethod_dolocallyrepair<ExperimentalWithCallbackMethod_docompleterepair<ExperimentalWithCallbackMethod_clearstripe<ExperimentalWithCallbackMethod_checkalive<ExperimentalWithCallbackMethod_handlepull<ExperimentalWithCallbackMethod_handlepush<ExperimentalWithCallbackMethod_pull_perform_push<ExperimentalWithCallbackMethod_renameblock<Service > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_handleupload<ExperimentalWithCallbackMethod_handledownload<ExperimentalWithCallbackMethod_clearallstripe<ExperimentalWithCallbackMethod_dolocallyrepair<ExperimentalWithCallbackMethod_docompleterepair<ExperimentalWithCallbackMethod_clearstripe<ExperimentalWithCallbackMethod_checkalive<ExperimentalWithCallbackMethod_handlepull<ExperimentalWithCallbackMethod_handlepush<ExperimentalWithCallbackMethod_pull_perform_push<ExperimentalWithCallbackMethod_renameblock<Service > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_handleupload() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_handledownload() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearallstripe() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_dolocallyrepair() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_docompleterepair() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearstripe() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_checkalive() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_handlepull() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_handlepush() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pull_perform_push() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_renameblock() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_handleupload() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandleupload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_handledownload() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandledownload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearallstripe() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclearallstripe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_dolocallyrepair() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdolocallyrepair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_docompleterepair() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdocompleterepair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearstripe() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclearstripe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_checkalive() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcheckalive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_handlepull() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandlepull(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_handlepush() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthandlepush(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pull_perform_push() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpull_perform_push(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_renameblock() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrenameblock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_handleupload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->handleupload(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handleupload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handleupload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_handledownload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->handledownload(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handledownload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handledownload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_clearallstripe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearallstripe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* clearallstripe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* clearallstripe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_dolocallyrepair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->dolocallyrepair(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* dolocallyrepair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* dolocallyrepair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_docompleterepair() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->docompleterepair(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* docompleterepair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* docompleterepair(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_clearstripe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearstripe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* clearstripe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* clearstripe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_checkalive() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->checkalive(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* checkalive(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* checkalive(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_handlepull() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->handlepull(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handlepull(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handlepull(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_handlepush() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->handlepush(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* handlepush(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* handlepush(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_pull_perform_push() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pull_perform_push(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* pull_perform_push(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* pull_perform_push(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_renameblock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->renameblock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* renameblock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* renameblock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_handleupload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_handleupload() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::UploadCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_handleupload<BaseClass>::Streamedhandleupload, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_handleupload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status handleupload(::grpc::ServerContext* /*context*/, const ::datanode::UploadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhandleupload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::UploadCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_handledownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_handledownload() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::DownloadCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_handledownload<BaseClass>::Streamedhandledownload, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_handledownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status handledownload(::grpc::ServerContext* /*context*/, const ::datanode::DownloadCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhandledownload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::DownloadCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearallstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearallstripe() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::ClearallstripeCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_clearallstripe<BaseClass>::Streamedclearallstripe, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_clearallstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearallstripe(::grpc::ServerContext* /*context*/, const ::datanode::ClearallstripeCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclearallstripe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::ClearallstripeCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dolocallyrepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_dolocallyrepair() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::NodesLocation, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_dolocallyrepair<BaseClass>::Streameddolocallyrepair, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dolocallyrepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dolocallyrepair(::grpc::ServerContext* /*context*/, const ::datanode::NodesLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddolocallyrepair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::NodesLocation,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_docompleterepair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_docompleterepair() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::StripeLocation, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_docompleterepair<BaseClass>::Streameddocompleterepair, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_docompleterepair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status docompleterepair(::grpc::ServerContext* /*context*/, const ::datanode::StripeLocation* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddocompleterepair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::StripeLocation,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearstripe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearstripe() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::StripeId, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_clearstripe<BaseClass>::Streamedclearstripe, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_clearstripe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearstripe(::grpc::ServerContext* /*context*/, const ::datanode::StripeId* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclearstripe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::StripeId,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_checkalive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_checkalive() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::CheckaliveCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_checkalive<BaseClass>::Streamedcheckalive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_checkalive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status checkalive(::grpc::ServerContext* /*context*/, const ::datanode::CheckaliveCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcheckalive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::CheckaliveCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_handlepull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_handlepull() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::HandlePullCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_handlepull<BaseClass>::Streamedhandlepull, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_handlepull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status handlepull(::grpc::ServerContext* /*context*/, const ::datanode::HandlePullCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhandlepull(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::HandlePullCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_handlepush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_handlepush() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::HandlePushCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_handlepush<BaseClass>::Streamedhandlepush, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_handlepush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status handlepush(::grpc::ServerContext* /*context*/, const ::datanode::HandlePushCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhandlepush(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::HandlePushCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pull_perform_push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pull_perform_push() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::OP, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_pull_perform_push<BaseClass>::Streamedpull_perform_push, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_pull_perform_push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pull_perform_push(::grpc::ServerContext* /*context*/, const ::datanode::OP* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpull_perform_push(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::OP,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_renameblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_renameblock() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::datanode::RenameCMD, ::datanode::RequestResult>(std::bind(&WithStreamedUnaryMethod_renameblock<BaseClass>::Streamedrenameblock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_renameblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status renameblock(::grpc::ServerContext* /*context*/, const ::datanode::RenameCMD* /*request*/, ::datanode::RequestResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrenameblock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::datanode::RenameCMD,::datanode::RequestResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_handleupload<WithStreamedUnaryMethod_handledownload<WithStreamedUnaryMethod_clearallstripe<WithStreamedUnaryMethod_dolocallyrepair<WithStreamedUnaryMethod_docompleterepair<WithStreamedUnaryMethod_clearstripe<WithStreamedUnaryMethod_checkalive<WithStreamedUnaryMethod_handlepull<WithStreamedUnaryMethod_handlepush<WithStreamedUnaryMethod_pull_perform_push<WithStreamedUnaryMethod_renameblock<Service > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_handleupload<WithStreamedUnaryMethod_handledownload<WithStreamedUnaryMethod_clearallstripe<WithStreamedUnaryMethod_dolocallyrepair<WithStreamedUnaryMethod_docompleterepair<WithStreamedUnaryMethod_clearstripe<WithStreamedUnaryMethod_checkalive<WithStreamedUnaryMethod_handlepull<WithStreamedUnaryMethod_handlepush<WithStreamedUnaryMethod_pull_perform_push<WithStreamedUnaryMethod_renameblock<Service > > > > > > > > > > > StreamedService;
};

// From Client to DN {typically for single block transfer}
class FromClient final {
 public:
  static constexpr char const* service_full_name() {
    return "datanode.FromClient";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
  };
  typedef Service AsyncService;
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef Service CallbackService;
  #endif

  typedef Service ExperimentalCallbackService;
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

}  // namespace datanode


#endif  // GRPC_datanode_2eproto__INCLUDED
